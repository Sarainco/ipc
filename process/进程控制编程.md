#### 1.为何需要多进程和并发

##### 1.1 进程

##### 1.2 进程的分类

* 进程一般分为交互进程、批处理进程和守护进程3类

##### 1.3 进程的属性

进程的属性包括以下几项

* 进程ID(PID)是唯一的数值，用来区分进程
* 父进程和父进程的ID(PPID)
* 启动进程的用户ID(UID)和所归属的组(GID)
* 进程状态分为运行(R)、休眠(S)和僵尸(Z)
* 进程执行的优先级
* 进程所连接的终端名
* 进程资源占用，例如占用资源大小（内存、CPU占用量）

##### 1.4 父进程和子进程

​	父进程和子进程的关系是管理和被管理的关系，当父进程终止时，子进程也随之而终止；但若子进程终止，父进程不一定终止。例如，当http服务器运行时，我们可以杀掉其子进程，父进程并不会因为子进程的终止而终止。

​	在进程管理中，当我们发现占用资源过多或者无法控制的进程时，应当杀死它，以保证系统稳定安全运行。

#### 2.Linux进程管理

##### 2.1 监视进程的工具：ps

##### 2.2 查询进程的工具：pgrep

##### 2.3 终止进程的工具：kill、killall、pkill和xkill

##### 2.4 监视系统任务的工具：top

##### 2.5 进程的优先级：nice和renice

#### 3.Linux进程的三态

进程在运行中不断地改变其运行状态，通常，一个运行进程具有以下三种状态。

##### 3.1 三种基本状态

* 就绪(Ready)状态。若进程以被分配到除CPU以外所有必要的资源，只要获得处理器便可立即执行，这是进程的状态被称为就绪态。
* 执行(Running)状态。当进程以获得处理器，其程序正在处理器上执行，此时的进程状态称为执行状态。
* 阻塞(Blocked)状态。当正在执行的进程，由于等待某个时间发生而无法执行时，便处于阻塞状态。引起进程阻塞的事件可能有很多种，例如等待I/O完成、申请缓冲区不能满足、等待信号等。

##### 3.2 三种基本状态的转换

一个进程在运行期间，会不断的从一种状态转换到另一种状态，它可以多次处于就绪状态和执行状态，也可以多次处于阻塞状态。

* 就绪--->执行。处于就绪状态的进程，当进程调度程序为之分配了处理器后，该进程便由就绪状态转变为执行状态。
* 执行--->就绪。处于执行状态的进程在执行过程中，因分配给它的一个时间片已用完不得不让出处理器，于是该京城便从执行状态编程就绪状态。
* 执行--->阻塞。当正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
* 阻塞--->就绪。处于阻塞状态的进程，若其等待的事件已经发生，便由阻塞状态转变为就绪状态。

![进程状态转换](https://github.com/Sarainco/yuji/blob/main/img_tool/fork/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2.png?raw=true)

#### 4.Linux进程结构

#### 5.Linux进程控制块PCB

#### 6.Linux进程调度

##### 6.1 调度的目标

##### 6.2 调度的算法

##### 6.3 优先级反转

#### 7.进程创建

##### 7.1 获取进程

##### 7.2 启动进程：fork()

##### 7.3 启动进程：vfork()

##### 7.4 启动进程：exec族

##### 7.5 启动进程：system

#### 8.进程等待

##### 8.1 僵尸进程的产生

##### 8.2 如何避免僵尸进程

##### 8.3 wait函数和waitpid函数

#### 9.进程退出

##### 9.1 退出方式的不同点

##### 9.2 exit函数和_exit函数

##### 9.3 exit函数和_exit函数的区别

#### 10.守护进程

##### 10.1 守护进程概述

##### 10.2 守护进程的创建

##### 10.3 创建守护进程的一般步骤

##### 10.4 利用库函数daemon创建守护进程